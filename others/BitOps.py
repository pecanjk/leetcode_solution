'''
bit ops
位运算
'''
#需要注意的是，用位运算代替其它运算方式（即第一种应用）在很多时候并不能带来太大的优化，反而会使代码变得复杂，使用时需要斟酌。
#（但像“乘 2 的非负整数次幂”和“除以 2 的非负整数次幂”就最好使用位运算，因为此时使用位运算可以优化复杂度。）

#n*(2^m)
n<<m


#n/(2^m)
n>>m

#!!! warning
#我们平常写的除法是向 0 取整，而这里的右移是向下取整（注意这里的区别），即当数大于等于 0 时两种方法等价，当数小于 0 时会有区别，如： -1 / 2 的值为 0 ，而 -1 >> 1 的值为 −1 。

// 如果 a>=b,(a-b)>>31 为 0，否则为 -1
def max(a,b):
	return b & ((a - b) >> 31) | a & (~(a - b) >> 31)


def min(a, b):
	return a & ((a - b) >> 31) | b & (~(a - b) >> 31)

print('max ',max(3,4))
print('min ',min(3,4))


// 获取 a 的第 b 位，最低位编号为 0

def getBit(a, b):
	return (a >> b) & 1
